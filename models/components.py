"""data"""
import datetime
from enum import Enum
import math
from econometrics import Cost
from geometry import GeoPosition, Orientation
from weather import Weather
import pandas as pd
from pandas import DataFrame


class Tech(Enum):
    """in this project will only use PV, but in the future will be expanded to other techs"""
    PHOTOVOLTAIC = 'fotovoltaico'
    SOLAR_THERMAL = 'solar térmico'


class Component:
    """each item in a project will be a component, as panels, invertor, etc"""
    def __init__(
        self,
        description:str,
        model:str = 'generic',
        specification:str|None = None,
        cost:Cost = Cost(),
        quantity:int = 1 ) -> None:
        self.description:str = description
        self.model:str = model
        self.specification:str|None = specification
        self.cost:float= cost
        self.quantity:int = quantity
    
    def total_brute_cost(self)->float:
        """cost before taxes"""
        return self.quantity*self.cost
    def total_cost_plus_taxes(self)->float:
        """cost after taxes"""
        return self.quantity*self.cost.netCost()

class Photovoltaic(Component):
    """pv panel tech"""
    energy:DataFrame = pd.DataFrame()


    def __init__(
        self, description: str,
        model: str = 'generic',
        specification: str | None = None,
        cost: Cost = Cost(),
        quantity: int = 1,
        power:int = 100,
        orientation:Orientation = Orientation()
        ) -> None:
        super().__init__(description, model, specification, cost, quantity)
        self.power = power
        self.orientation = orientation

    def normal(self)->dict[str,float]:
        """elevation and azimuth surface´s normal"""
        return {'azimuth':self.orientation.inclination,'elevation':self.orientation.inclination}

    def cos_phi(self,date:datetime,location:GeoPosition)->float:
        """or angle between sun and normal or surface"""
        # https://www.cdeep.iitb.ac.in/slides/S20/EN301/EN301-L8.pdf
            # Sun:
            # X_sun = cos(elevation_sun) * cos(azimuth_sun)
            # Y_sun = cos(elevation_sun) * sin(azimuth_sun)
            # Z_sun = sin(elevation_sun)
            # Para la normal del surface:
            # X_normal = sin(inclination_surface) * cos(azimuth_surface)
            # Y_normal = sin(inclination_surface) * sin(azimuth_surface)
            # Z_normal = cos(inclination_surface)
            # cos(θ) = X_sun * X_normal + Y_sun * Y_normal + Z_sun * Z_normal   
        sun= location.sun_position(date)

        [x_sun,y_sun,z_sun] = [
            math.cos(math.radians(sun['elevation']))*math.cos(math.radians(sun['azimuth'])),
            math.cos(math.radians(sun['elevation']))*math.sin(math.radians(sun['azimuth'])),
            math.sin(math.radians(sun['elevation']))
            ]
        
        normal = self.normal()

        [x_nor,y_nor,z_nor] = [
            math.sin(math.radians(normal['elevation']))*math.cos(math.radians(normal['azimuth'])),
            math.sin(math.radians(normal['elevation']))*math.sin(math.radians(normal['azimuth'])),
            math.cos(math.radians(normal['elevation']))
            ]
        cos_phi = x_sun*x_nor + y_sun*y_nor + z_sun*z_nor
        return cos_phi

    def calc_energy(self,weather:Weather):
        """calc amount of energy generated by year"""
        #fetch nasa weather data
        data = weather.get_data()
        return None #temp (\n)